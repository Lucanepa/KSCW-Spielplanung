<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Team Matches Calendar v10</title>
  <link 
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" 
    rel="stylesheet"
    integrity="sha384-â€¦"
    crossorigin="anonymous">
  <style>
    body { background: #f8f9fa; padding: 20px; }
    table.calendar { width: 100%; table-layout: fixed; margin-bottom: 40px; }
    .calendar th, .calendar td {
      border: 1px solid #ddd;
      padding: 5px;
      vertical-align: top;
      height: 100px;
      font-size: 12px;
      position: relative;
    }
    .calendar th { background: #007bff; color: white; }
    .match, .preference {
      display: block;
      margin: 2px 0;
      padding: 2px 4px;
      border-radius: 3px;
      font-size: 11px;
      color: black;
      position: relative;
    }
    .match small.status {
      position: absolute;
      top: 2px; right: 4px;
      color: #555;
      font-size: 9px;
    }
    .closure {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0.8;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: white;
    }
    .preference {
      border: 1px dashed #17a2b8;
      background: rgba(23,162,184,0.1);
      font-style: italic;
      color: #0c5460;
    }
  </style>
</head>
<body>
  <h4>ðŸ“… Team Matches Planning v10</h4>
  <button class="btn btn-primary mb-3" onclick="loadData()">ðŸ”„ Refresh</button>
  <div id="calendar-container"></div>

  <script>
    // === CONFIG ===
    const SPREADSHEET_ID = '16hr2bshVSHoQGZ73xGZiJpnhlBwu6Mn3I5YC4Z-ixXY';
    const API_KEY        = 'AIzaSyB4tX_WxrFRajdEdqVI-yTWV0uRNqJQkfc'; // Replace with your actual API key
    const RANGES         = [
      'Luca - Team_Matches',
      'Luca - Gym Closed',
      'Luca - Team_Preferences'
    ];

    const teamColor = {
      'Damen 1': '#e74c3c',
      'Damen 2': '#f39c12',
      'Damen 3': '#f1c40f',
      'Damen 4': '#de16ca',
      'DU23 1':  '#16a085',
      'DU23 2':  '#2980b9',
      'Herren 1':'#bd8fe3',
      'Herren 2':'#d35400',
      'Herren 3':'#4cb55c',
      'HU23':    '#7f8c8d'
    };

    function getRandomColor() {
      return '#' + Math.floor(Math.random() * 0xFFFFFF)
                      .toString(16).padStart(6, '0');
    }

    // never throws, returns '' if invalid
    function parseDateDMY(dmy='') {
      if (typeof dmy !== 'string' || !dmy.includes('/')) return '';
      const [d, m, y] = dmy.split('/');
      if (!d || !m || !y) return '';
      return `${y}-${m.padStart(2,'0')}-${d.padStart(2,'0')}`;
    }

    async function loadData() {
      const url = `https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values:batchGet?` +
                  RANGES.map(r => `ranges=${encodeURIComponent(r)}`).join('&') +
                  `&majorDimension=ROWS&key=${API_KEY}`;

      const res = await fetch(url);
      if (!res.ok) {
        console.error('Sheets API error:', await res.text());
        alert('Failed to load data from Google Sheets. Check console for details.');
        return;
      }
      const { valueRanges } = await res.json();

      // 1) MATCHES
      const rawMatches = valueRanges[0].values || [];
      if (rawMatches.length < 2) {
        renderCalendar([], []);
        return;
      }

      const headers = rawMatches[0]
        .map(h => h ? h.toString().trim().toLowerCase() : '');
      const idx = name => headers.indexOf(name.toLowerCase());

      const iTeam   = idx('team');
      const iOpp    = idx('opponent team');
      const iDate   = idx('date');
      const iTime   = idx('time');
      const iType   = idx('type');
      const iStatus = idx('status');
      const iGym    = idx('gym/halle'); // New column index

      console.log('MATCH HEADERS:', headers);
      console.log({ iTeam, iOpp, iDate, iTime, iType, iStatus, iGym });

      let matches = rawMatches.slice(1).map(r => {
        const dateRaw = r[iDate] || '';
        const isoDate = parseDateDMY(dateRaw);
        return {
          team:     r[iTeam]   || '',
          opponent: r[iOpp]    || '',
          date:     isoDate,
          time:     r[iTime]   || '',
          type:     r[iType]   || '',
          status:   r[iStatus] || '',
          gym:      r[iGym]    || '', // Store gym information
          isPref:   false
        };
      })
      .filter(m => /^\d{4}-\d{2}-\d{2}$/.test(m.date));

      // 2) CLOSURES
      const rawClosures = valueRanges[1].values || [];
      const closures = [];
      if (rawClosures.length > 1) {
          rawClosures.slice(1).forEach(r => {
            const fromDateStr = parseDateDMY(r[0]);
            const toDateStr = parseDateDMY(r[1]);
            if (!fromDateStr || !toDateStr) return;

            const from = new Date(fromDateStr);
            const to   = new Date(toDateStr);
            const reason = (r[2]||'').toLowerCase();
            for (let d = new Date(from); d <= to; d.setDate(d.getDate()+1)) {
              closures.push({ date: d.toISOString().slice(0,10), reason });
            }
          });
      }


      // 3) PREFERENCES
      const rawPrefs = valueRanges[2].values || [];
      if (rawPrefs.length > 1) {
        const pHeaders = rawPrefs[0].map(h => h ? h.toString().trim().toLowerCase() : '');
        const pIdx     = name => pHeaders.indexOf(name.toLowerCase());
        rawPrefs.slice(1).forEach(r => {
          const team     = r[pIdx('team')];
          const pref     = r[pIdx('preference')];
          const allDay   = r[pIdx('all day?')];
          const dateFrom = r[pIdx('date from')];
          const dateTo   = r[pIdx('date to')];
          const timeFrom = r[pIdx('time from')];
          const timeTo   = r[pIdx('time to')];
          if (!team || !pref || !dateFrom || !dateTo) return;

          const isAll = String(allDay).toLowerCase() === 'yes';
          const startDateStr = parseDateDMY(dateFrom);
          const endDateStr = parseDateDMY(dateTo);
          if (!startDateStr || !endDateStr) return;

          const start = new Date(startDateStr);
          const end   = new Date(endDateStr);

          for (let d = new Date(start); d <= end; d.setDate(d.getDate()+1)) {
            const iso = d.toISOString().slice(0,10);
            let desc = `Team ${team} ${pref.toUpperCase()}`;
            let prefTime = '';
            if (!isAll && timeFrom && timeTo) {
                desc += ` from ${timeFrom} to ${timeTo}`;
                prefTime = timeFrom;
            } else if (!isAll && timeFrom) { // Handle if only timeFrom is provided
                desc += ` from ${timeFrom}`;
                prefTime = timeFrom;
            }


            matches.push({
              team, opponent: '', date: iso,
              time: prefTime,
              type: desc, status: '', isPref: true, gym: ''
            });
          }
        });
      }

      renderCalendar(matches, closures);
    }

    function renderCalendar(matches, closures) {
      const container = document.getElementById('calendar-container');
      container.innerHTML = '';

      const byMatch = {};
      matches.forEach(e => {
        byMatch[e.date] = byMatch[e.date] || [];
        byMatch[e.date].push(e);
        if (!teamColor[e.team] && e.team) teamColor[e.team] = getRandomColor();
      });
      Object.values(byMatch).forEach(arr =>
        arr.sort((a,b) => (a.time || '00:00').localeCompare(b.time || '00:00'))
      );
      const byClose = {};
      closures.forEach(c => byClose[c.date] = c.reason);

      const months = [];
      let cur = new Date(2025,8,1), end = new Date(2026,3,30); // Extended to end of April
      while (cur <= end) {
        months.push(new Date(cur));
        cur.setMonth(cur.getMonth()+1);
      }
      const weekdays = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];

      months.forEach(dateObj => {
        const y = dateObj.getFullYear(), m = dateObj.getMonth();
        const first = new Date(y,m,1), last = new Date(y,m+1,0);
        let html =
          `<table class="calendar">
             <thead>
               <tr><th colspan="7">${first.toLocaleString('en-GB',{month:'long',year:'numeric'})}</th></tr>
               <tr>${weekdays.map(d=>`<th>${d}</th>`).join('')}</tr>
             </thead>
             <tbody><tr>`;

        const offset = (first.getDay()+6)%7;
        html += '<td></td>'.repeat(offset);

        for (let d = 1; d <= last.getDate(); d++) {
          const key    = `${y}-${String(m+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
          const evs    = byMatch[key] || [];
          const reason = byClose[key];
          let cell = `<td><strong>${d}</strong>`;

          evs.forEach(e => {
            let mainDisplayInfo = '';
            let additionalInfoLine = ''; // For "Type - Gym" or similar

            if (!e.isPref) { // This is a Match
              let teamVsOpponent = '';
              const tLower = e.type ? e.type.toLowerCase() : '';
              if (e.opponent) {
                if (tLower.includes('home'))      teamVsOpponent = `${e.team} - ${e.opponent}`;
                else if (tLower.includes('away')) teamVsOpponent = `${e.opponent} - ${e.team}`;
                else                              teamVsOpponent = `${e.team} vs ${e.opponent}`;
              } else {
                teamVsOpponent = e.team; // E.g., for training
              }
              mainDisplayInfo = teamVsOpponent;

              let typeAndGym = '';
              if (e.type) {
                typeAndGym = e.type;
                if (e.gym) {
                  typeAndGym += ` - ${e.gym}`;
                }
              } else if (e.gym) { // Only gym is present
                typeAndGym = e.gym;
              }
              if (typeAndGym) {
                additionalInfoLine = typeAndGym;
              }

            } else { // This is a Preference
              mainDisplayInfo = e.type; // e.type for preference is already descriptive
            }

            let style = '';
            if (!e.isPref && e.team) {
              if (e.status.trim().toLowerCase() === 'waiting') {
                style = `border:1px solid ${teamColor[e.team] || '#ccc'}`;
              } else {
                style = `background:${teamColor[e.team] || getRandomColor()}`;
              }
            }

            let entryText = '';
            if (e.isPref) entryText += 'ðŸ”¹ ';
            if (e.time) {
                entryText += e.time;
                if (mainDisplayInfo) entryText += ' â€“ ';
            }
            // If no time but there's info, and it's not a preference (which already has its marker)
            // ensure mainDisplayInfo is added even if time is missing.
            // For preferences, if time is missing, we don't want a ' â€“ '.
            if (mainDisplayInfo) {
                if (!e.time && e.isPref) { // Preference, no time, no leading separator
                    entryText += mainDisplayInfo;
                } else if (!e.time && !e.isPref && mainDisplayInfo) { // Match, no time, no leading separator
                    entryText += mainDisplayInfo;
                }
                else if (e.time) { // Time is present, separator already added
                    entryText += mainDisplayInfo;
                }
            }


            cell += `<div class="${e.isPref ? 'preference':'match'}" style="${style}">
                       ${entryText}
                       ${e.status ? `<small class="status">${e.status}</small>` : ''}
                       ${additionalInfoLine ? `<br>${additionalInfoLine}` : ''}
                     </div>`;
          });

          if (reason) {
            const bg    = reason==='holiday'? '#6c757d':'#000';
            const label = reason.charAt(0).toUpperCase()+reason.slice(1);
            cell += `<div class="closure" style="background:${bg}">${label}</div>`;
          }

          cell += '</td>';
          html += cell;
          if ((offset + d - 1) % 7 === 6) html += '</tr><tr>';
        }
        // Fill remaining cells in the last row if any
        const remainingCells = (7 - (offset + last.getDate()) % 7) % 7;
        html += '<td></td>'.repeat(remainingCells);

        html += '</tr></tbody></table>';
        container.insertAdjacentHTML('beforeend', html);
      });
    }

    document.addEventListener('DOMContentLoaded', loadData);
  </script>
</body>
</html>
